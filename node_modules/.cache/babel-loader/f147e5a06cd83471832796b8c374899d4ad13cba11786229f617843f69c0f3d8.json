{"ast":null,"code":"var _jsxFileName = \"/app/src/components/maps/panoLayer/PanoLayer.tsx\",\n  _s = $RefreshSig$();\nimport React, { useState, useEffect, useCallback, useMemo } from 'react';\nimport { useMap } from 'react-leaflet';\nimport debounce from 'lodash/debounce';\nimport { Marker } from 'react-leaflet';\nimport MarkerClusterGroup from 'react-leaflet-cluster';\nimport { defaultIcon, activeIcon } from '../../icons';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst MIN_ZOOM_LEVEL = 10; // Минимальный уровень зума для загрузки маркеров\n\nconst PanoLayer = ({\n  selectedMarker,\n  onMarkerClick\n}) => {\n  _s();\n  const [markers, setMarkers] = useState([]);\n  const [isLoading, setIsLoading] = useState(false);\n  const [loadedBounds, setLoadedBounds] = useState([]);\n  const map = useMap();\n\n  // Функция для получения маркеров в пределах экстента\n  const fetchMarkersInBounds = useCallback(async bounds => {\n    if (isLoading || !bounds) return;\n\n    // Проверяем уровень зума\n    if (map.getZoom() < MIN_ZOOM_LEVEL) {\n      return;\n    }\n    const north = bounds.getNorth();\n    const south = bounds.getSouth();\n    const east = bounds.getEast();\n    const west = bounds.getWest();\n\n    // Округляем координаты до 2 знаков после запятой для уменьшения количества запросов\n    const boundsKey = `${north.toFixed(2)},${south.toFixed(2)},${east.toFixed(2)},${west.toFixed(2)}`;\n\n    // Проверяем, не загружали ли мы уже маркеры для этих границ\n    if (loadedBounds.includes(boundsKey)) {\n      return;\n    }\n    setIsLoading(true);\n    try {\n      const response = await fetch(`https://api.botplus.ru/panoramas?north=${north}&south=${south}&east=${east}&west=${west}`);\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      const data = await response.json();\n      if (!Array.isArray(data)) {\n        console.error('Invalid data format received:', data);\n        return;\n      }\n      const newMarkers = data.filter(item => item && (typeof item.id === 'string' || typeof item.id === 'number') && typeof item.latitude === 'number' && typeof item.longitude === 'number').map(item => ({\n        id: item.id.toString(),\n        lat: item.latitude,\n        lng: item.longitude\n      }));\n\n      // Объединяем новые маркеры с существующими, избегая дубликатов\n      setMarkers(prevMarkers => {\n        const existingIds = new Set(prevMarkers.map(m => m.id));\n        const uniqueNewMarkers = newMarkers.filter(m => !existingIds.has(m.id));\n        return [...prevMarkers, ...uniqueNewMarkers];\n      });\n\n      // Добавляем текущие границы в список загруженных\n      setLoadedBounds(prev => [...prev, boundsKey]);\n    } catch (error) {\n      console.error('Error fetching panoramas:', error);\n    } finally {\n      setIsLoading(false);\n    }\n  }, [isLoading, map]);\n\n  // Дебаунсированная версия функции загрузки маркеров\n  const debouncedFetchMarkers = useMemo(() => debounce(bounds => {\n    fetchMarkersInBounds(bounds);\n  }, 1000),\n  // Увеличиваем задержку до 1 секунды\n  [fetchMarkersInBounds]);\n\n  // Обработчик изменения экстента карты\n  useEffect(() => {\n    if (!map) return;\n    const handleMoveEnd = () => {\n      const bounds = map.getBounds();\n      if (bounds) {\n        debouncedFetchMarkers(bounds);\n      }\n    };\n    map.on('moveend', handleMoveEnd);\n\n    // Загружаем начальные маркеры только если зум достаточный\n    if (map.getZoom() >= MIN_ZOOM_LEVEL) {\n      const initialBounds = map.getBounds();\n      if (initialBounds) {\n        fetchMarkersInBounds(initialBounds);\n      }\n    }\n    return () => {\n      map.off('moveend', handleMoveEnd);\n      debouncedFetchMarkers.cancel();\n    };\n  }, [map, debouncedFetchMarkers, fetchMarkersInBounds]);\n\n  // Мемоизируем компонент MarkerClusterGroup для предотвращения лишних перерендеров\n  const markerCluster = useMemo(() => /*#__PURE__*/_jsxDEV(MarkerClusterGroup, {\n    disableClusteringAtZoom: 18,\n    maxClusterRadius: 50,\n    chunkedLoading: true,\n    children: markers.map((marker, index) => /*#__PURE__*/_jsxDEV(Marker, {\n      position: [marker.lat, marker.lng],\n      // Используем id маркера вместо сгенерированного ключа\n      icon: selectedMarker === marker.id ? activeIcon : defaultIcon,\n      eventHandlers: {\n        click: () => onMarkerClick(marker)\n      }\n    }, marker.id, false, {\n      fileName: _jsxFileName,\n      lineNumber: 146,\n      columnNumber: 9\n    }, this))\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 140,\n    columnNumber: 5\n  }, this), [markers, selectedMarker, onMarkerClick]);\n  return markerCluster;\n};\n_s(PanoLayer, \"ZD3LGs82dyntBH2vSGS1VPTQeHs=\", false, function () {\n  return [useMap];\n});\n_c = PanoLayer;\nexport default PanoLayer;\nvar _c;\n$RefreshReg$(_c, \"PanoLayer\");","map":{"version":3,"names":["React","useState","useEffect","useCallback","useMemo","useMap","debounce","Marker","MarkerClusterGroup","defaultIcon","activeIcon","jsxDEV","_jsxDEV","MIN_ZOOM_LEVEL","PanoLayer","selectedMarker","onMarkerClick","_s","markers","setMarkers","isLoading","setIsLoading","loadedBounds","setLoadedBounds","map","fetchMarkersInBounds","bounds","getZoom","north","getNorth","south","getSouth","east","getEast","west","getWest","boundsKey","toFixed","includes","response","fetch","ok","Error","status","data","json","Array","isArray","console","error","newMarkers","filter","item","id","latitude","longitude","toString","lat","lng","prevMarkers","existingIds","Set","m","uniqueNewMarkers","has","prev","debouncedFetchMarkers","handleMoveEnd","getBounds","on","initialBounds","off","cancel","markerCluster","disableClusteringAtZoom","maxClusterRadius","chunkedLoading","children","marker","index","position","icon","eventHandlers","click","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/app/src/components/maps/panoLayer/PanoLayer.tsx"],"sourcesContent":["import React, { useState, useEffect, useCallback, useMemo } from 'react';\nimport { useMap } from 'react-leaflet';\nimport debounce from 'lodash/debounce';\nimport { Marker } from 'react-leaflet';\nimport MarkerClusterGroup from 'react-leaflet-cluster';\nimport { defaultIcon, activeIcon } from '../../icons';\nimport { LatLngBounds } from 'leaflet';\n\ninterface MarkerType {\n  id: string;\n  lat: number;\n  lng: number;\n}\n\ninterface PanoramaItem {\n  id: number | string;\n  latitude: number;\n  longitude: number;\n  [key: string]: any;\n}\n\ninterface PanoLayerProps {\n  selectedMarker: string | null;\n  onMarkerClick: (marker: MarkerType) => void;\n}\n\nconst MIN_ZOOM_LEVEL = 10; // Минимальный уровень зума для загрузки маркеров\n\nconst PanoLayer: React.FC<PanoLayerProps> = ({ selectedMarker, onMarkerClick }) => {\n  const [markers, setMarkers] = useState<MarkerType[]>([]);\n  const [isLoading, setIsLoading] = useState(false);\n  const [loadedBounds, setLoadedBounds] = useState<string[]>([]);\n  const map = useMap();\n\n  // Функция для получения маркеров в пределах экстента\n  const fetchMarkersInBounds = useCallback(async (bounds: LatLngBounds) => {\n    if (isLoading || !bounds) return;\n\n    // Проверяем уровень зума\n    if (map.getZoom() < MIN_ZOOM_LEVEL) {\n      return;\n    }\n\n    const north = bounds.getNorth();\n    const south = bounds.getSouth();\n    const east = bounds.getEast();\n    const west = bounds.getWest();\n\n    // Округляем координаты до 2 знаков после запятой для уменьшения количества запросов\n    const boundsKey = `${north.toFixed(2)},${south.toFixed(2)},${east.toFixed(2)},${west.toFixed(2)}`;\n\n    // Проверяем, не загружали ли мы уже маркеры для этих границ\n    if (loadedBounds.includes(boundsKey)) {\n      return;\n    }\n\n    setIsLoading(true);\n    try {\n      const response = await fetch(\n        `https://api.botplus.ru/panoramas?north=${north}&south=${south}&east=${east}&west=${west}`\n      );\n      \n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n\n      const data = await response.json();\n\n      if (!Array.isArray(data)) {\n        console.error('Invalid data format received:', data);\n        return;\n      }\n\n      const newMarkers = data\n        .filter((item: any): item is PanoramaItem => \n          item && \n          (typeof item.id === 'string' || typeof item.id === 'number') && \n          typeof item.latitude === 'number' && \n          typeof item.longitude === 'number'\n        )\n        .map(item => ({\n          id: item.id.toString(),\n          lat: item.latitude,\n          lng: item.longitude,\n        }));\n\n      // Объединяем новые маркеры с существующими, избегая дубликатов\n      setMarkers(prevMarkers => {\n        const existingIds = new Set(prevMarkers.map(m => m.id));\n        const uniqueNewMarkers = newMarkers.filter(m => !existingIds.has(m.id));\n        return [...prevMarkers, ...uniqueNewMarkers];\n      });\n\n      // Добавляем текущие границы в список загруженных\n      setLoadedBounds(prev => [...prev, boundsKey]);\n    } catch (error) {\n      console.error('Error fetching panoramas:', error);\n    } finally {\n      setIsLoading(false);\n    }\n  }, [isLoading, map]);\n\n  // Дебаунсированная версия функции загрузки маркеров\n  const debouncedFetchMarkers = useMemo(\n    () => debounce((bounds: LatLngBounds) => {\n      fetchMarkersInBounds(bounds);\n    }, 1000), // Увеличиваем задержку до 1 секунды\n    [fetchMarkersInBounds]\n  );\n\n  // Обработчик изменения экстента карты\n  useEffect(() => {\n    if (!map) return;\n\n    const handleMoveEnd = () => {\n      const bounds = map.getBounds();\n      if (bounds) {\n        debouncedFetchMarkers(bounds);\n      }\n    };\n\n    map.on('moveend', handleMoveEnd);\n\n    // Загружаем начальные маркеры только если зум достаточный\n    if (map.getZoom() >= MIN_ZOOM_LEVEL) {\n      const initialBounds = map.getBounds();\n      if (initialBounds) {\n        fetchMarkersInBounds(initialBounds);\n      }\n    }\n\n    return () => {\n      map.off('moveend', handleMoveEnd);\n      debouncedFetchMarkers.cancel();\n    };\n  }, [map, debouncedFetchMarkers, fetchMarkersInBounds]);\n\n  // Мемоизируем компонент MarkerClusterGroup для предотвращения лишних перерендеров\n  const markerCluster = useMemo(() => (\n    <MarkerClusterGroup \n      disableClusteringAtZoom={18} \n      maxClusterRadius={50}\n      chunkedLoading={true}\n    >\n      {markers.map((marker, index) => (\n        <Marker\n          position={[marker.lat, marker.lng]}\n          key={marker.id} // Используем id маркера вместо сгенерированного ключа\n          icon={selectedMarker === marker.id ? activeIcon : defaultIcon}\n          eventHandlers={{ click: () => onMarkerClick(marker) }}\n        />\n      ))}\n    </MarkerClusterGroup>\n  ), [markers, selectedMarker, onMarkerClick]);\n\n  return markerCluster;\n};\n\nexport default PanoLayer;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}