{"ast":null,"code":"var _jsxFileName = \"/app/src/components/maps/panoLayer/PanoLayer.tsx\",\n  _s = $RefreshSig$();\nimport React, { useState, useEffect, useCallback } from 'react';\nimport { useMap } from 'react-leaflet';\nimport debounce from 'lodash/debounce';\nimport { Marker } from 'react-leaflet';\nimport MarkerClusterGroup from 'react-leaflet-cluster';\nimport { defaultIcon, activeIcon } from '../../icons';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst PanoLayer = ({\n  selectedMarker,\n  onMarkerClick\n}) => {\n  _s();\n  const [markers, setMarkers] = useState([]);\n  const [isLoading, setIsLoading] = useState(false);\n  const [loadedBounds, setLoadedBounds] = useState([]);\n  const map = useMap();\n\n  // Функция для получения маркеров в пределах экстента\n  const fetchMarkersInBounds = async bounds => {\n    if (isLoading || !bounds) return;\n    const north = bounds.getNorth();\n    const south = bounds.getSouth();\n    const east = bounds.getEast();\n    const west = bounds.getWest();\n    const boundsKey = `${north.toFixed(2)},${south.toFixed(2)},${east.toFixed(2)},${west.toFixed(2)}`;\n\n    // Проверяем, не загружали ли мы уже маркеры для этих границ\n    if (loadedBounds.includes(boundsKey)) {\n      return;\n    }\n    setIsLoading(true);\n    try {\n      console.log('Fetching markers for bounds:', {\n        north,\n        south,\n        east,\n        west\n      });\n      const response = await fetch(`https://api.botplus.ru/panoramas?north=${north}&south=${south}&east=${east}&west=${west}`);\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      const data = await response.json();\n      console.log('Received data:', data);\n      console.log('First item in data:', data[0]);\n      console.log('Data type:', typeof data);\n      console.log('Is array:', Array.isArray(data));\n      if (!Array.isArray(data)) {\n        console.error('Invalid data format received:', data);\n        return;\n      }\n      const newMarkers = data.filter(item => {\n        const isValid = item && typeof item.id === 'string' && typeof item.latitude === 'number' && typeof item.longitude === 'number';\n        if (!isValid) {\n          console.log('Invalid item:', item);\n          console.log('Item properties:', {\n            hasId: item === null || item === void 0 ? void 0 : item.id,\n            idType: typeof (item === null || item === void 0 ? void 0 : item.id),\n            hasLat: item === null || item === void 0 ? void 0 : item.latitude,\n            latType: typeof (item === null || item === void 0 ? void 0 : item.latitude),\n            hasLng: item === null || item === void 0 ? void 0 : item.longitude,\n            lngType: typeof (item === null || item === void 0 ? void 0 : item.longitude)\n          });\n        }\n        return isValid;\n      }).map(item => {\n        console.log('Processing item:', item);\n        return {\n          id: item.id,\n          lat: item.latitude,\n          lng: item.longitude\n        };\n      });\n      console.log('Created markers:', newMarkers);\n\n      // Объединяем новые маркеры с существующими, избегая дубликатов\n      setMarkers(prevMarkers => {\n        const existingIds = new Set(prevMarkers.map(m => m.id));\n        const uniqueNewMarkers = newMarkers.filter(m => !existingIds.has(m.id));\n        const result = [...prevMarkers, ...uniqueNewMarkers];\n        console.log('Updated markers:', result);\n        return result;\n      });\n\n      // Добавляем текущие границы в список загруженных\n      setLoadedBounds(prev => [...prev, boundsKey]);\n    } catch (error) {\n      console.error('Error fetching panoramas:', error);\n      console.error('Error details:', {\n        message: error instanceof Error ? error.message : 'Unknown error',\n        stack: error instanceof Error ? error.stack : undefined\n      });\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  // Дебаунсированная версия функции загрузки маркеров\n  const debouncedFetchMarkers = useCallback(debounce(bounds => {\n    fetchMarkersInBounds(bounds);\n  }, 500), []);\n\n  // Обработчик изменения экстента карты\n  useEffect(() => {\n    if (!map) return;\n    const handleMoveEnd = () => {\n      const bounds = map.getBounds();\n      if (bounds) {\n        debouncedFetchMarkers(bounds);\n      }\n    };\n    map.on('moveend', handleMoveEnd);\n\n    // Загружаем начальные маркеры\n    const initialBounds = map.getBounds();\n    if (initialBounds) {\n      fetchMarkersInBounds(initialBounds);\n    }\n    return () => {\n      map.off('moveend', handleMoveEnd);\n      debouncedFetchMarkers.cancel();\n    };\n  }, [map, debouncedFetchMarkers]);\n  console.log('Rendering markers:', markers);\n  return /*#__PURE__*/_jsxDEV(MarkerClusterGroup, {\n    disableClusteringAtZoom: 18,\n    maxClusterRadius: 50,\n    children: markers.map((marker, index) => {\n      console.log('Rendering marker:', marker);\n      return /*#__PURE__*/_jsxDEV(Marker, {\n        position: [marker.lat, marker.lng],\n        icon: selectedMarker === marker.id ? activeIcon : defaultIcon,\n        eventHandlers: {\n          click: () => onMarkerClick(marker)\n        }\n      }, `${marker.lat}-${marker.lng}-${index}`, false, {\n        fileName: _jsxFileName,\n        lineNumber: 165,\n        columnNumber: 11\n      }, this);\n    })\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 161,\n    columnNumber: 5\n  }, this);\n};\n_s(PanoLayer, \"qzqS2pZTvS1wpJI4jlNkqaEefSc=\", false, function () {\n  return [useMap];\n});\n_c = PanoLayer;\nexport default PanoLayer;\nvar _c;\n$RefreshReg$(_c, \"PanoLayer\");","map":{"version":3,"names":["React","useState","useEffect","useCallback","useMap","debounce","Marker","MarkerClusterGroup","defaultIcon","activeIcon","jsxDEV","_jsxDEV","PanoLayer","selectedMarker","onMarkerClick","_s","markers","setMarkers","isLoading","setIsLoading","loadedBounds","setLoadedBounds","map","fetchMarkersInBounds","bounds","north","getNorth","south","getSouth","east","getEast","west","getWest","boundsKey","toFixed","includes","console","log","response","fetch","ok","Error","status","data","json","Array","isArray","error","newMarkers","filter","item","isValid","id","latitude","longitude","hasId","idType","hasLat","latType","hasLng","lngType","lat","lng","prevMarkers","existingIds","Set","m","uniqueNewMarkers","has","result","prev","message","stack","undefined","debouncedFetchMarkers","handleMoveEnd","getBounds","on","initialBounds","off","cancel","disableClusteringAtZoom","maxClusterRadius","children","marker","index","position","icon","eventHandlers","click","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/app/src/components/maps/panoLayer/PanoLayer.tsx"],"sourcesContent":["import React, { useState, useEffect, useCallback } from 'react';\nimport { useMap } from 'react-leaflet';\nimport debounce from 'lodash/debounce';\nimport { Marker } from 'react-leaflet';\nimport MarkerClusterGroup from 'react-leaflet-cluster';\nimport { defaultIcon, activeIcon } from '../../icons';\nimport { LatLngBounds } from 'leaflet';\n\ninterface MarkerType {\n  id: string;\n  lat: number;\n  lng: number;\n}\n\ninterface PanoramaItem {\n  id: string;\n  latitude: number;\n  longitude: number;\n  [key: string]: any;\n}\n\ninterface PanoLayerProps {\n  selectedMarker: string | null;\n  onMarkerClick: (marker: MarkerType) => void;\n}\n\nconst PanoLayer: React.FC<PanoLayerProps> = ({ selectedMarker, onMarkerClick }) => {\n  const [markers, setMarkers] = useState<MarkerType[]>([]);\n  const [isLoading, setIsLoading] = useState(false);\n  const [loadedBounds, setLoadedBounds] = useState<string[]>([]);\n  const map = useMap();\n\n  // Функция для получения маркеров в пределах экстента\n  const fetchMarkersInBounds = async (bounds: LatLngBounds) => {\n    if (isLoading || !bounds) return;\n\n    const north = bounds.getNorth();\n    const south = bounds.getSouth();\n    const east = bounds.getEast();\n    const west = bounds.getWest();\n\n    const boundsKey = `${north.toFixed(2)},${south.toFixed(2)},${east.toFixed(2)},${west.toFixed(2)}`;\n\n    // Проверяем, не загружали ли мы уже маркеры для этих границ\n    if (loadedBounds.includes(boundsKey)) {\n      return;\n    }\n\n    setIsLoading(true);\n    try {\n      console.log('Fetching markers for bounds:', { north, south, east, west });\n      \n      const response = await fetch(\n        `https://api.botplus.ru/panoramas?north=${north}&south=${south}&east=${east}&west=${west}`\n      );\n      \n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n\n      const data = await response.json();\n      console.log('Received data:', data);\n      console.log('First item in data:', data[0]);\n      console.log('Data type:', typeof data);\n      console.log('Is array:', Array.isArray(data));\n\n      if (!Array.isArray(data)) {\n        console.error('Invalid data format received:', data);\n        return;\n      }\n\n      const newMarkers = data\n        .filter((item: any): item is PanoramaItem => {\n          const isValid = item && \n            typeof item.id === 'string' && \n            typeof item.latitude === 'number' && \n            typeof item.longitude === 'number';\n          \n          if (!isValid) {\n            console.log('Invalid item:', item);\n            console.log('Item properties:', {\n              hasId: item?.id,\n              idType: typeof item?.id,\n              hasLat: item?.latitude,\n              latType: typeof item?.latitude,\n              hasLng: item?.longitude,\n              lngType: typeof item?.longitude\n            });\n          }\n          return isValid;\n        })\n        .map(item => {\n          console.log('Processing item:', item);\n          return {\n            id: item.id,\n            lat: item.latitude,\n            lng: item.longitude,\n          };\n        });\n\n      console.log('Created markers:', newMarkers);\n\n      // Объединяем новые маркеры с существующими, избегая дубликатов\n      setMarkers(prevMarkers => {\n        const existingIds = new Set(prevMarkers.map(m => m.id));\n        const uniqueNewMarkers = newMarkers.filter(m => !existingIds.has(m.id));\n        const result = [...prevMarkers, ...uniqueNewMarkers];\n        console.log('Updated markers:', result);\n        return result;\n      });\n\n      // Добавляем текущие границы в список загруженных\n      setLoadedBounds(prev => [...prev, boundsKey]);\n    } catch (error) {\n      console.error('Error fetching panoramas:', error);\n      console.error('Error details:', {\n        message: error instanceof Error ? error.message : 'Unknown error',\n        stack: error instanceof Error ? error.stack : undefined\n      });\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  // Дебаунсированная версия функции загрузки маркеров\n  const debouncedFetchMarkers = useCallback(\n    debounce((bounds: LatLngBounds) => {\n      fetchMarkersInBounds(bounds);\n    }, 500),\n    []\n  );\n\n  // Обработчик изменения экстента карты\n  useEffect(() => {\n    if (!map) return;\n\n    const handleMoveEnd = () => {\n      const bounds = map.getBounds();\n      if (bounds) {\n        debouncedFetchMarkers(bounds);\n      }\n    };\n\n    map.on('moveend', handleMoveEnd);\n\n    // Загружаем начальные маркеры\n    const initialBounds = map.getBounds();\n    if (initialBounds) {\n      fetchMarkersInBounds(initialBounds);\n    }\n\n    return () => {\n      map.off('moveend', handleMoveEnd);\n      debouncedFetchMarkers.cancel();\n    };\n  }, [map, debouncedFetchMarkers]);\n\n  console.log('Rendering markers:', markers);\n\n  return (\n    <MarkerClusterGroup disableClusteringAtZoom={18} maxClusterRadius={50}>\n      {markers.map((marker, index) => {\n        console.log('Rendering marker:', marker);\n        return (\n          <Marker\n            position={[marker.lat, marker.lng]}\n            key={`${marker.lat}-${marker.lng}-${index}`}\n            icon={selectedMarker === marker.id ? activeIcon : defaultIcon}\n            eventHandlers={{ click: () => onMarkerClick(marker) }}\n          />\n        );\n      })}\n    </MarkerClusterGroup>\n  );\n};\n\nexport default PanoLayer;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}