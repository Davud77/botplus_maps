{"ast":null,"code":"var _jsxFileName = \"/app/src/components/maps/panoLayer/PanoLayer.tsx\",\n  _s = $RefreshSig$();\nimport React, { useState, useEffect, useCallback, useMemo } from 'react';\nimport { useMap } from 'react-leaflet';\nimport debounce from 'lodash/debounce';\nimport { Marker } from 'react-leaflet';\nimport MarkerClusterGroup from 'react-leaflet-cluster';\nimport { defaultIcon, activeIcon } from '../../icons';\nimport { LatLng } from 'leaflet';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\n// Константы для оптимизации\nconst MIN_ZOOM_LEVEL = 10;\nconst MAX_MARKERS_PER_REQUEST = 1000;\nconst CLUSTER_SIZES = {\n  far: {\n    zoom: 10,\n    radius: 80\n  },\n  medium: {\n    zoom: 14,\n    radius: 60\n  },\n  near: {\n    zoom: 16,\n    radius: 40\n  },\n  closest: {\n    zoom: 18,\n    radius: 0\n  }\n};\nconst PanoLayer = ({\n  selectedMarker,\n  onMarkerClick\n}) => {\n  _s();\n  const [markers, setMarkers] = useState([]);\n  const [isLoading, setIsLoading] = useState(false);\n  const [loadedBounds, setLoadedBounds] = useState([]);\n  const [visibleMarkers, setVisibleMarkers] = useState([]);\n  const map = useMap();\n\n  // Функция для определения размера кластера в зависимости от зума\n  const getClusterRadius = useCallback(zoom => {\n    if (zoom >= CLUSTER_SIZES.closest.zoom) return CLUSTER_SIZES.closest.radius;\n    if (zoom >= CLUSTER_SIZES.near.zoom) return CLUSTER_SIZES.near.radius;\n    if (zoom >= CLUSTER_SIZES.medium.zoom) return CLUSTER_SIZES.medium.radius;\n    return CLUSTER_SIZES.far.radius;\n  }, []);\n\n  // Функция для фильтрации маркеров в видимой области\n  const updateVisibleMarkers = useCallback(() => {\n    if (!map) return;\n    const bounds = map.getBounds();\n    const zoom = map.getZoom();\n\n    // При маленьком зуме показываем только часть маркеров для оптимизации\n    const skipFactor = zoom < 12 ? 10 : zoom < 14 ? 5 : 1;\n    const visible = markers.filter((marker, index) => {\n      // Пропускаем часть маркеров на маленьком зуме\n      if (index % skipFactor !== 0) return false;\n      return bounds.contains(new LatLng(marker.lat, marker.lng));\n    });\n    setVisibleMarkers(visible);\n  }, [map, markers]);\n\n  // Функция для получения маркеров в пределах экстента\n  const fetchMarkersInBounds = useCallback(async bounds => {\n    if (isLoading || !bounds) return;\n    const zoom = map.getZoom();\n    if (zoom < MIN_ZOOM_LEVEL) {\n      setVisibleMarkers([]);\n      return;\n    }\n    const north = bounds.getNorth();\n    const south = bounds.getSouth();\n    const east = bounds.getEast();\n    const west = bounds.getWest();\n\n    // Округляем координаты с разной точностью в зависимости от зума\n    const precision = zoom > 15 ? 4 : zoom > 12 ? 3 : 2;\n    const boundsKey = `${north.toFixed(precision)},${south.toFixed(precision)},${east.toFixed(precision)},${west.toFixed(precision)}`;\n    if (loadedBounds.includes(boundsKey)) {\n      updateVisibleMarkers();\n      return;\n    }\n    setIsLoading(true);\n    try {\n      const response = await fetch(`https://api.botplus.ru/panoramas?north=${north}&south=${south}&east=${east}&west=${west}&limit=${MAX_MARKERS_PER_REQUEST}`);\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      const data = await response.json();\n      if (!Array.isArray(data)) {\n        console.error('Invalid data format received:', data);\n        return;\n      }\n      const newMarkers = data.filter(item => item && (typeof item.id === 'string' || typeof item.id === 'number') && typeof item.latitude === 'number' && typeof item.longitude === 'number').map(item => ({\n        id: item.id.toString(),\n        lat: item.latitude,\n        lng: item.longitude\n      }));\n      setMarkers(prevMarkers => {\n        const existingIds = new Set(prevMarkers.map(m => m.id));\n        const uniqueNewMarkers = newMarkers.filter(m => !existingIds.has(m.id));\n        const updatedMarkers = [...prevMarkers, ...uniqueNewMarkers];\n\n        // Обновляем видимые маркеры после добавления новых\n        requestAnimationFrame(() => {\n          updateVisibleMarkers();\n        });\n        return updatedMarkers;\n      });\n      setLoadedBounds(prev => [...prev, boundsKey]);\n    } catch (error) {\n      console.error('Error fetching panoramas:', error);\n    } finally {\n      setIsLoading(false);\n    }\n  }, [isLoading, map, loadedBounds, updateVisibleMarkers]);\n\n  // Дебаунсированная версия функции загрузки маркеров\n  const debouncedFetchMarkers = useMemo(() => debounce(bounds => {\n    fetchMarkersInBounds(bounds);\n  }, 1000), [fetchMarkersInBounds]);\n\n  // Обработчик изменения экстента карты\n  useEffect(() => {\n    if (!map) return;\n    const handleMoveEnd = () => {\n      const bounds = map.getBounds();\n      if (bounds) {\n        debouncedFetchMarkers(bounds);\n      }\n    };\n    const handleZoomEnd = () => {\n      updateVisibleMarkers();\n    };\n    map.on('moveend', handleMoveEnd);\n    map.on('zoomend', handleZoomEnd);\n    if (map.getZoom() >= MIN_ZOOM_LEVEL) {\n      const initialBounds = map.getBounds();\n      if (initialBounds) {\n        fetchMarkersInBounds(initialBounds);\n      }\n    }\n    return () => {\n      map.off('moveend', handleMoveEnd);\n      map.off('zoomend', handleZoomEnd);\n      debouncedFetchMarkers.cancel();\n    };\n  }, [map, debouncedFetchMarkers, fetchMarkersInBounds, updateVisibleMarkers]);\n\n  // Мемоизируем компонент MarkerClusterGroup\n  const markerCluster = useMemo(() => {\n    const zoom = map.getZoom();\n    const clusterRadius = getClusterRadius(zoom);\n    return /*#__PURE__*/_jsxDEV(MarkerClusterGroup, {\n      disableClusteringAtZoom: CLUSTER_SIZES.closest.zoom,\n      maxClusterRadius: clusterRadius,\n      chunkedLoading: true,\n      spiderfyOnMaxZoom: true,\n      removeOutsideVisibleBounds: true,\n      animate: false,\n      children: visibleMarkers.map(marker => /*#__PURE__*/_jsxDEV(Marker, {\n        position: [marker.lat, marker.lng],\n        icon: selectedMarker === marker.id ? activeIcon : defaultIcon,\n        eventHandlers: {\n          click: () => onMarkerClick(marker)\n        }\n      }, marker.id, false, {\n        fileName: _jsxFileName,\n        lineNumber: 202,\n        columnNumber: 11\n      }, this))\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 193,\n      columnNumber: 7\n    }, this);\n  }, [visibleMarkers, selectedMarker, onMarkerClick, map, getClusterRadius]);\n  return markerCluster;\n};\n_s(PanoLayer, \"kyiBDFy/7vVXWCMDRSXVX91JlWI=\", false, function () {\n  return [useMap];\n});\n_c = PanoLayer;\nexport default PanoLayer;\nvar _c;\n$RefreshReg$(_c, \"PanoLayer\");","map":{"version":3,"names":["React","useState","useEffect","useCallback","useMemo","useMap","debounce","Marker","MarkerClusterGroup","defaultIcon","activeIcon","LatLng","jsxDEV","_jsxDEV","MIN_ZOOM_LEVEL","MAX_MARKERS_PER_REQUEST","CLUSTER_SIZES","far","zoom","radius","medium","near","closest","PanoLayer","selectedMarker","onMarkerClick","_s","markers","setMarkers","isLoading","setIsLoading","loadedBounds","setLoadedBounds","visibleMarkers","setVisibleMarkers","map","getClusterRadius","updateVisibleMarkers","bounds","getBounds","getZoom","skipFactor","visible","filter","marker","index","contains","lat","lng","fetchMarkersInBounds","north","getNorth","south","getSouth","east","getEast","west","getWest","precision","boundsKey","toFixed","includes","response","fetch","ok","Error","status","data","json","Array","isArray","console","error","newMarkers","item","id","latitude","longitude","toString","prevMarkers","existingIds","Set","m","uniqueNewMarkers","has","updatedMarkers","requestAnimationFrame","prev","debouncedFetchMarkers","handleMoveEnd","handleZoomEnd","on","initialBounds","off","cancel","markerCluster","clusterRadius","disableClusteringAtZoom","maxClusterRadius","chunkedLoading","spiderfyOnMaxZoom","removeOutsideVisibleBounds","animate","children","position","icon","eventHandlers","click","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/app/src/components/maps/panoLayer/PanoLayer.tsx"],"sourcesContent":["import React, { useState, useEffect, useCallback, useMemo } from 'react';\nimport { useMap } from 'react-leaflet';\nimport debounce from 'lodash/debounce';\nimport { Marker } from 'react-leaflet';\nimport MarkerClusterGroup from 'react-leaflet-cluster';\nimport { defaultIcon, activeIcon } from '../../icons';\nimport { LatLngBounds, LatLng } from 'leaflet';\n\ninterface MarkerType {\n  id: string;\n  lat: number;\n  lng: number;\n}\n\ninterface PanoramaItem {\n  id: number | string;\n  latitude: number;\n  longitude: number;\n  [key: string]: any;\n}\n\ninterface PanoLayerProps {\n  selectedMarker: string | null;\n  onMarkerClick: (marker: MarkerType) => void;\n}\n\n// Константы для оптимизации\nconst MIN_ZOOM_LEVEL = 10;\nconst MAX_MARKERS_PER_REQUEST = 1000;\nconst CLUSTER_SIZES = {\n  far: { zoom: 10, radius: 80 },\n  medium: { zoom: 14, radius: 60 },\n  near: { zoom: 16, radius: 40 },\n  closest: { zoom: 18, radius: 0 }\n};\n\nconst PanoLayer: React.FC<PanoLayerProps> = ({ selectedMarker, onMarkerClick }) => {\n  const [markers, setMarkers] = useState<MarkerType[]>([]);\n  const [isLoading, setIsLoading] = useState(false);\n  const [loadedBounds, setLoadedBounds] = useState<string[]>([]);\n  const [visibleMarkers, setVisibleMarkers] = useState<MarkerType[]>([]);\n  const map = useMap();\n\n  // Функция для определения размера кластера в зависимости от зума\n  const getClusterRadius = useCallback((zoom: number) => {\n    if (zoom >= CLUSTER_SIZES.closest.zoom) return CLUSTER_SIZES.closest.radius;\n    if (zoom >= CLUSTER_SIZES.near.zoom) return CLUSTER_SIZES.near.radius;\n    if (zoom >= CLUSTER_SIZES.medium.zoom) return CLUSTER_SIZES.medium.radius;\n    return CLUSTER_SIZES.far.radius;\n  }, []);\n\n  // Функция для фильтрации маркеров в видимой области\n  const updateVisibleMarkers = useCallback(() => {\n    if (!map) return;\n\n    const bounds = map.getBounds();\n    const zoom = map.getZoom();\n    \n    // При маленьком зуме показываем только часть маркеров для оптимизации\n    const skipFactor = zoom < 12 ? 10 : zoom < 14 ? 5 : 1;\n\n    const visible = markers.filter((marker, index) => {\n      // Пропускаем часть маркеров на маленьком зуме\n      if (index % skipFactor !== 0) return false;\n      \n      return bounds.contains(new LatLng(marker.lat, marker.lng));\n    });\n\n    setVisibleMarkers(visible);\n  }, [map, markers]);\n\n  // Функция для получения маркеров в пределах экстента\n  const fetchMarkersInBounds = useCallback(async (bounds: LatLngBounds) => {\n    if (isLoading || !bounds) return;\n\n    const zoom = map.getZoom();\n    if (zoom < MIN_ZOOM_LEVEL) {\n      setVisibleMarkers([]);\n      return;\n    }\n\n    const north = bounds.getNorth();\n    const south = bounds.getSouth();\n    const east = bounds.getEast();\n    const west = bounds.getWest();\n\n    // Округляем координаты с разной точностью в зависимости от зума\n    const precision = zoom > 15 ? 4 : zoom > 12 ? 3 : 2;\n    const boundsKey = `${north.toFixed(precision)},${south.toFixed(precision)},${east.toFixed(precision)},${west.toFixed(precision)}`;\n\n    if (loadedBounds.includes(boundsKey)) {\n      updateVisibleMarkers();\n      return;\n    }\n\n    setIsLoading(true);\n    try {\n      const response = await fetch(\n        `https://api.botplus.ru/panoramas?north=${north}&south=${south}&east=${east}&west=${west}&limit=${MAX_MARKERS_PER_REQUEST}`\n      );\n      \n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n\n      const data = await response.json();\n\n      if (!Array.isArray(data)) {\n        console.error('Invalid data format received:', data);\n        return;\n      }\n\n      const newMarkers = data\n        .filter((item: any): item is PanoramaItem => \n          item && \n          (typeof item.id === 'string' || typeof item.id === 'number') && \n          typeof item.latitude === 'number' && \n          typeof item.longitude === 'number'\n        )\n        .map(item => ({\n          id: item.id.toString(),\n          lat: item.latitude,\n          lng: item.longitude,\n        }));\n\n      setMarkers(prevMarkers => {\n        const existingIds = new Set(prevMarkers.map(m => m.id));\n        const uniqueNewMarkers = newMarkers.filter(m => !existingIds.has(m.id));\n        const updatedMarkers = [...prevMarkers, ...uniqueNewMarkers];\n        \n        // Обновляем видимые маркеры после добавления новых\n        requestAnimationFrame(() => {\n          updateVisibleMarkers();\n        });\n        \n        return updatedMarkers;\n      });\n\n      setLoadedBounds(prev => [...prev, boundsKey]);\n    } catch (error) {\n      console.error('Error fetching panoramas:', error);\n    } finally {\n      setIsLoading(false);\n    }\n  }, [isLoading, map, loadedBounds, updateVisibleMarkers]);\n\n  // Дебаунсированная версия функции загрузки маркеров\n  const debouncedFetchMarkers = useMemo(\n    () => debounce((bounds: LatLngBounds) => {\n      fetchMarkersInBounds(bounds);\n    }, 1000),\n    [fetchMarkersInBounds]\n  );\n\n  // Обработчик изменения экстента карты\n  useEffect(() => {\n    if (!map) return;\n\n    const handleMoveEnd = () => {\n      const bounds = map.getBounds();\n      if (bounds) {\n        debouncedFetchMarkers(bounds);\n      }\n    };\n\n    const handleZoomEnd = () => {\n      updateVisibleMarkers();\n    };\n\n    map.on('moveend', handleMoveEnd);\n    map.on('zoomend', handleZoomEnd);\n\n    if (map.getZoom() >= MIN_ZOOM_LEVEL) {\n      const initialBounds = map.getBounds();\n      if (initialBounds) {\n        fetchMarkersInBounds(initialBounds);\n      }\n    }\n\n    return () => {\n      map.off('moveend', handleMoveEnd);\n      map.off('zoomend', handleZoomEnd);\n      debouncedFetchMarkers.cancel();\n    };\n  }, [map, debouncedFetchMarkers, fetchMarkersInBounds, updateVisibleMarkers]);\n\n  // Мемоизируем компонент MarkerClusterGroup\n  const markerCluster = useMemo(() => {\n    const zoom = map.getZoom();\n    const clusterRadius = getClusterRadius(zoom);\n\n    return (\n      <MarkerClusterGroup \n        disableClusteringAtZoom={CLUSTER_SIZES.closest.zoom}\n        maxClusterRadius={clusterRadius}\n        chunkedLoading={true}\n        spiderfyOnMaxZoom={true}\n        removeOutsideVisibleBounds={true}\n        animate={false}\n      >\n        {visibleMarkers.map((marker) => (\n          <Marker\n            position={[marker.lat, marker.lng]}\n            key={marker.id}\n            icon={selectedMarker === marker.id ? activeIcon : defaultIcon}\n            eventHandlers={{ click: () => onMarkerClick(marker) }}\n          />\n        ))}\n      </MarkerClusterGroup>\n    );\n  }, [visibleMarkers, selectedMarker, onMarkerClick, map, getClusterRadius]);\n\n  return markerCluster;\n};\n\nexport default PanoLayer;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}